# MALO Y REDUNDANTE

# Define neural network model
# Basic feedforward neural network by TensorFlow/Keras
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

# Define a simple neural network model
def create_model():
    model = Sequential([
        Dense(64, activation='relu', input_shape=(input_dim,)),
        Dense(32, activation='relu'),
        Dense(1, activation='sigmoid')
    ])
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return model

# Define the input dimension based on your feature set
input_dim = 64

# Create a function that takes a position as input
# Apply neural network model & returns if it meets the requirements or not
def analyze_position(position):
    # Preprocess the position using the NQueens class
    n_queens_instance = NQueens(
        number_pieces=position.number_pieces,
        number_spaces=position.number_spaces,
        row=position.row,
        column=position.column,
        diagonal=position.diagonal
    )

    # Get the board with limit positions
    board_with_limit_positions = n_queens_instance.board

    # Load your data and preprocess it as needed based on the board_with_limit_positions
    # For example, you can flatten the board and scale the values to match the input dimension
    features = preprocess(board_with_limit_positions)

    # Create and compile the model
    model = create_model()

    # Load pre-trained weights if available
    # model.load_weights('model_weights.h5')

    # Predict whether the position meets the requirements
    prediction = model.predict(features)

    return prediction[0][0] >= 0.5  # Assuming 0.5 is your threshold for meeting the requirements

# Analyze positions concurrently
import concurrent.futures

# Create a list of NQueens instances representing the positions to analyze
positions_to_analyze = [
    NQueens(number_pieces=8, number_spaces=8, row=2, column=3, diagonal=5),
    NQueens(number_pieces=8, number_spaces=8, row=3, column=0, diagonal=6),
    # Add more positions as needed
]

# Number of concurrent threads (adjust according to your system's capabilities)
num_threads = 4

# Analyze positions concurrently
import concurrent.futures

# Create a list of NQueens instances representing the positions to analyze
positions_to_analyze = [
    NQueens(number_pieces=8, number_spaces=8, row=2, column=3, diagonal=5),
    NQueens(number_pieces=8, number_spaces=8, row=3, column=0, diagonal=6),
    # Add more positions as needed
]

# Number of concurrent threads (adjust according to your system's capabilities)
num_threads = 4

# Define the input dimension based on your feature set
input_dim = 64

# Create a function to analyze positions
def analyze_position(position):
    # Get the necessary attributes from the NQueens instance
    n = position.n
    s = position.s
    i = position.i
    j = position.j
    k = position.k
    
    # Calculate the limit positions based on the attributes
    n_queens_instance = NQueens(number_pieces=n, number_spaces=s, row=i, column=j, diagonal=k)
    board_with_limit_positions = n_queens_instance.board

    # Flatten the board and scale the values to match the input dimension
    features = board_with_limit_positions.flatten() / s

    # Create and compile the model
    model = create_model()

    # Load pre-trained weights if available
    # model.load_weights('model_weights.h5')

    # Predict whether the position meets the requirements
    prediction = model.predict(features.reshape(1, -1))
    
    return prediction[0][0] >= 0.5  # Assuming 0.5 is your threshold for meeting the requirements

# Analyze positions concurrently
with concurrent.futures.ThreadPoolExecutor(max_workers=num_threads) as executor:
    results = list(executor.map(analyze_position, positions_to_analyze))
